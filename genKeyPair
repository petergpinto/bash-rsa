#Pseudocode
#
#I will be using openssl to generate the primes for the key since I dont trust myself to generate those with sufficent randomness
#P and Q are large random primes
#choose p
p=$(openssl prime -generate -bits 16)
#choose q
q=$(openssl prime -generate -bits 16)

#n is the modulus for the public and private keys
#n = p*q
n=$(($p*$q))

greatestCommonDivisor()
{
	if [[ $1 -gt $2 ]]; then
		a=$1
		b=$2
	else
		a=$2
		b=$1
	fi
	
	multiple=$b
	while [ "$multiple" -gt 0 ]; do
		x=$(($a % $multiple))
		y=$(($b % $multiple))

		if [[ $x -eq 0 ]] && [[ $y -eq 0 ]]; then
			return $multiple
		fi
		multiple=$(($multiple-1))
	done
	return 1

}

leastCommonMultiple ()
{
	a=$1
	b=$2
	greatestCommonDivisor $1 $2
	num=$?
	num2=$(( $a * $b ))
	lcm=$(( $num2 / $num ))
	return $lcm
}

#This value is kept private
#totient = leastCommonMultiple( p-1, q-1 )
leastCommonMultiple $p $q
totient=$?


#choose e: 	1 < e < totient, e coprime to totient (e and totient share no factors other than one)
bits=0
temp=$totient
while [ $temp -ne 0 ]; do
	temp=$(($temp>>1))
	bits=$(($bits+1))
done
bits=$(($bits-1))
e=$(openssl prime -generate -bits $bits)

modInverse () 
{
	a=$1
	b=$2
	a=$(($a % $b))
	for i in $(seq 1 $b); do
		if [ $(( ( $a* $i ) % $b )) -eq 1 ]; then
			return $i
		fi
	done
}

#compute d:	d = e-1 (mod totient)
leastCommonMultiple $(($p -1)) $(($q -1))
c=$?
modInverse $e $c
d=$?
#public key is n, e
echo "public key: " $n " " $e

#private key is d
echo "private key: " $d

greatestCommonDivisor()
{
	if [[ $1 -gt $2 ]]; then
		a=$1
		b=$2
	else
		a=$2
		b=$1
	fi
	
	multiple=$b
	while [ $multiple -gt 0 ]; do
		x=$(($a % $multiple))
		y=$(($b % $multiple))

		if [[ $x -eq 0 ]] && [[ $y -eq 0 ]]; then
			return $multiple
		fi
		multiple=$(($multiple-1))
	done
	return 1

}

leastCommonMultiple ()
{
	a=$1
	b=$2
	greatestCommonDivisor $1 $2
	num=$?
	num2=$(( $a * $b ))
	lcm=$(( $num2 / $num ))
	return $lcm
}
